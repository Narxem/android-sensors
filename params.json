{
  "name": "Android-sensors",
  "tagline": "TP découverte de l'utilisation des capteurs",
  "body": "# TP Android : Les capteurs\r\n\r\n## Introduction\r\n\r\nDe nombreuses applications présentes sur le store utilisent les capteurs de notre téléphone. Ces capteurs sont toujours de plus en plus nombreux. Dans ce tutoriel, vous allez apprendre comment les exploiter.\r\n\r\nDans ce tutoriel, j'indiquerai _comme ceci_ les fichiers et/ou méthodes dans lesquelles il faut décommenter des instructions\r\n\r\n## 1 - Demander la présence d'un capteur\r\n\r\nIl peut arriver qu'une application ne peut être utilisée que si le device dispose d'un capteur spécifique. Il n'aurait en effet pas de sens de télécharger un jeu basé sur l'accélèromètre si ce dernier n'est pas présent.\r\n\r\nDans ce cas, on ajoute un tag dans le manifest. Par exemple, pour l'accélèromètre, on ajoutera : \r\n```xml\r\n<use-feature android:name=\"android.hardware.sensor.accelerometer\" android:required=\"true\"/>\r\n```\r\n_AndroidManifest.xml_\r\n\r\nLe paramètre `required` à `true` signifie que le capteur est obligatoire et interdit le téléchargement de l'application s'il n'est pas présent. On peut le mettre à `false` pour indiquer à l'utilisateur que le capteur n'est pas obligatoire mais fortement recommandé.\r\n\r\n## 2 - Accès aux capteurs\r\n\r\nL'accès aux capteurs se fait via la classe `SensorManager`. Elle permet d'obtenir des informations sur les capteurs présents sur le device.\r\n\r\nPour en obtenir une instance :\r\n```java\r\nSensorManager sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);\r\n```\r\n_MainActivity.java -> onCreate()_\r\n\r\n### Utilisation de `SensorManager`\r\n\r\n* `List<Sensor> getSensorList(int type)` : obtenir la liste des capteurs du type passé en paramètre (les types seront listés plus loin)\r\n* `Sensor getDefaultSensor(int type)` : obtenir le capteur par défaut du type passé en paramètre\r\n\r\n\r\nL'entier passé en paramètre est un id de type de capteur. Ces constantes sont définies dans la classe `Sensor`. Les plus utilisées sont :\r\n* `TYPE_ACCELEROMETER` pour l'accélèromètre\r\n* `TYPE_GYROSCOPE` pour le gyroscope\r\n* `TYPE_LIGHT` pour le capteur de lumière\r\n* `TYPE_PROXIMITY` pour le capteur de proximité\r\n* `TYPE_ALL` pour tous les capteurs. Utile dans `getSensorList()` pour obtenir la liste de tous les capteurs\r\n\r\nPour obtenir un capteur :\r\n```java\r\nSensor accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);\r\n```\r\n_MainActivity.java -> onStart()_\r\n\r\nPensez à toujours vérifier si le capteur a bien été trouvé, car s'il n'est pas présent, alors cette méthode vous renverra `null` et fera planter votre application par une jolie `NullPointerException` si vous tentez d'utiliser la variable directement ! Prévoyez toujours un comportement à adopter si aucun capteur n'est présent.\r\n\r\n_MainActivity.java -> onStart()_\r\n\r\n## 3 - Exploitation du capteur\r\n\r\nNous allons maintenant faire appel à une nouvelle interface : `SensorEventListener` qui va écouter nos capteurs pour transmettre les valeurs.\r\n\r\n\r\nIl faudra alors créer une classe qui implémente cette interface, et qui contiendra 2 méthodes :\r\n\r\n### `void onAccuracyChanged(Sensor sensor, int accuracy)`\r\nCette méthode est appelée en cas de changement de précision du capteur. Dans notre cas, on peut tout simplement ne rien faire.\r\n\r\n\r\n### `void onSensorChanged(SensorEvent event)`\r\nCette méthode nous interresse plus, elle est appelée dès que le capteur detecte un changement. L'objet `SensorEvent` contient des données utiles : \r\n* `event.sensor` : le capteur en question\r\n* `event.accuracy` : la précision du capteur\r\n* `event.timestamp` : la nanoseconde à laquelle le changement a été détecté\r\n* `event.values` : un tableau de `float` contenant les valeurs qui nous interressent\r\n\r\nIl faut donc faire notre traitement dans cette méthode. \r\n/!\\ : Il ne faut JAMAIS lancer d'opération bloquante ou d'opération gourmande en mémoire ici, car cette méthode sera invoquée très souvent. Vous pourriez saturer la mémoire du device très rapidement.\r\n\r\n_MainActivity.java -> Classe interne `AccelerometerListener`_\r\n_MainActivity.jave -> ligne 30 (`SensorEventListener`)_\r\n\r\n## 4 - Ecoute du capteur\r\n\r\nDernière étape : nous avons notre listener, il faut maintenant écouter notre capteur.\r\nOn fait cela de nouveau à l'aide de notre objet `SensorManager`.\r\nOn utilise la méthode `registerListener(SensorEventListener listener, Sensor sensor, int delay)` avec\r\n* `listener` : une instance du `SensorEventListener` que nous venons de créer\r\n* `sensor` : le capteur à écouter\r\n* `delay` : le délai entre chaque écoute. Cela peut être :\r\n    - `sensorManager.SENSOR_DELAY_NORMAL` : pour une écoute \"normale\", c'est le délai le plus lent\r\n    - `sensorManager.SENSOR_DELAY_UI` : plus rapide, pour une écoute qui met à jour l'interface\r\n    - `sensorManager.SENSOR_DELAY_GAME` : encore plus rapide, pour une utilisation en jeu\r\n    - `sensorManager.SENSOR_DELAY_FASTEST` : le plus rapide, rarement utile.\r\n\r\nEnfin, il ne faut pas oublier de désactiver le listener avec la méthode `unregisterListener(SensorEventListener listener)` lorsqu'on ne l'utilise pas. Je conseille de le faire dans le `onPause()` ou le `onStop()` (et donc `registerListener` respectivement dans `onResume()` ou `onStart()`).\r\n\r\n_MainActivity.java -> onStop()_\r\n\r\n\r\n# TP\r\n\r\nVous pouvez maintenant tenter d'exploiter ce tutoriel pour utiliser le capteur d'orientation de votre téléphone\r\n\r\nL'activité (improprement) appelée `GyroscopeActivity` affiche une image et fournie une méthode permettant de faire subir une rotation à cette image. \r\n\r\nA vous de faire en sorte de le creeper reste toujours dans le même sens quand vous pivotez votre téléphone / tablette (l'activité est verouillée en mode portrait)\r\n\r\nVous disposez de plusieurs possibilités pour la créaction de votre listener : \r\n* Vous pouvez faire un classe interne, comme dans la `MainActivity.java`\r\n* Vous pouvez en faire un classe anonyme au moment de l'enregistrement du capteur et du listener\r\n* Vous pouvez faire que l'activité implémente `SensorEventListener` et définir directement les méthode dans l'activité. A ce moment la, mettez `this` comme listener au moment de l'enregistrement\r\n\r\nEnfin, `GyroscopeActivity` contient la méthode `rotateCreeper(float angle)` pour faire tourner l'image d'un certain angle (en degrés) par rapport à sa position de départ\r\n\r\nN'hésitez pas à vous inspirer de `MainActivity` si vous avez des difficultés.\r\n\r\n\r\n### Solution\r\nUne solution se trouve sur la branche final-code. Pour y acceder :\r\n```bash\r\ngit checkout final-code\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}